46 # slide
00:00:00,000 --> 00:00:07,410
Having dealt with graphs in
the last video, and having done

00:00:07,410 --> 00:00:15,870
so using this little puzzle, this video
will on one hand be about something much

00:00:15,870 --> 00:00:23,880
more specific to computer science, and on the
other hand, it won't be about graphs either.

00:00:23,880 --> 00:00:28,380
I had said that we would be doing
a lot of modeling with graphs, but

00:00:28,380 --> 00:00:34,620
we actually need (especially in preparation
for UML) one more ingredient that is textual.

00:00:34,620 --> 00:00:36,750
Namely, static modeling of operations.

00:00:37,800 --> 00:00:40,890
And that's what this video
is going to be about.

00:00:40,890 --> 00:00:47,430
Because it's a prerequisite and
preparation for object-oriented class

00:00:47,430 --> 00:00:52,620
design, or modeling classes
and especially their methods.

00:00:52,620 --> 00:00:54,210
But we will get to that later.

00:00:54,210 --> 00:00:58,500
First of all, generally,
and also detached from UML.

00:00:58,500 --> 00:01:01,140
In fact, operations play a

00:01:01,140 --> 00:01:04,770
role in mathematics as well as in computer
science, independent of object-orientation.

00:01:05,520 --> 00:01:10,650
What are we talking about specifically,
also in the context of computer science?

00:01:10,650 --> 00:01:13,050
Let's assume we want to
design a system in computer

00:01:13,050 --> 00:01:15,450
science, be it a program or a database.

00:01:15,450 --> 00:01:17,850
Then, often the first question is

00:01:17,850 --> 00:01:20,460
which operations should be
offered and implemented.

00:01:20,460 --> 00:01:24,810
And at least as importantly, besides
simply the names of operations,

00:01:24,810 --> 00:01:28,080
also on which data they are to work.

00:01:28,080 --> 00:01:31,950
This is about static modeling.

00:01:31,950 --> 00:01:33,480
Ultimately, it is about
the structure of the system

00:01:33,480 --> 00:01:36,750
or the functionalities and
services offered by the system.

00:01:36,750 --> 00:01:42,150
So it is not about what
exactly the operations will do,

00:01:42,150 --> 00:01:46,470
but first of all, for example, which
calls/uses should be syntactically allowed.

00:01:46,470 --> 00:01:50,700
What should even be meaningful
operations uses,

00:01:50,700 --> 00:01:53,670
and also how operations
can be combined.

00:01:53,670 --> 00:01:56,250
Usually a system will
consist of many functionalities,

00:01:56,250 --> 00:02:01,110
which may have to be used in combination.

00:02:03,060 --> 00:02:05,220
And at least that would be
important for documentation.

00:02:06,090 --> 00:02:13,950
So we can learn about the
system simply by capturing

00:02:13,950 --> 00:02:17,190
this static information, even without
having to look at the implementation.

00:02:17,190 --> 00:02:21,390
And ideally it would also help
with the implementation, for

00:02:22,200 --> 00:02:27,780
example, by precisely recording which
cases of input have to be handled at all.

00:02:27,780 --> 00:02:33,540
Or, by using consistency checks
to possibly avoid certain

00:02:33,540 --> 00:02:36,720
errors, even before testing
or trying to prove anything.

00:02:36,720 --> 00:02:40,110
Simply by having
recorded beforehand what the

00:02:40,110 --> 00:02:43,950
operations are called (the names are
also important) but also on which

00:02:43,950 --> 00:02:50,010
types of data they operate and which
combinations of operations should be allowed.

00:02:51,630 --> 00:02:55,440
Then, during programming, during
implementation, errors can be uncovered that

00:02:55,440 --> 00:02:59,130
might otherwise only be noticed during
operation or when the system has been

00:02:59,130 --> 00:03:00,870
implemented and is to be tested.

00:03:03,240 --> 00:03:04,890
I'll first explain with a very simple

00:03:04,890 --> 00:03:07,140
example, so to speak
in a very simple domain.

00:03:07,800 --> 00:03:10,680
Operations always refer to
a specific application area.

00:03:10,680 --> 00:03:12,930
And the application domain
that you know from school,

00:03:12,930 --> 00:03:16,650
where you have encountered
operations, is simply arithmetic.

00:03:16,650 --> 00:03:20,250
So the arithmetic operations are
called: "plus", "minus", "times", etc.

00:03:20,250 --> 00:03:22,350
These are, of course,
operations in this sense.

00:03:22,350 --> 00:03:25,530
And depending on what we
then work with in a

00:03:25,530 --> 00:03:28,050
system, we naturally have to
deal with more than just numbers.

00:03:28,050 --> 00:03:29,790
But numbers will probably always

00:03:29,790 --> 00:03:32,250
be involved in some way in a program.

00:03:32,250 --> 00:03:34,620
So let's imagine, naively:

00:03:34,620 --> 00:03:37,290
We might want to design a calculator app.

00:03:37,290 --> 00:03:42,450
Then, the relevant operations we
probably want to offer are at

00:03:42,450 --> 00:03:45,030
least the usual arithmetic operations.

00:03:45,030 --> 00:03:46,830
And maybe we've decided that

00:03:46,830 --> 00:03:50,325
we want to take the set of
natural numbers, including zero.

00:03:50,325 --> 00:03:54,900
So we don't do fractional numbers
or floating point numbers first.

00:03:54,900 --> 00:03:57,210
Then we could say:

00:03:57,210 --> 00:04:01,710
Well, then addition is a binary operation
(because it takes two arguments,

00:04:01,710 --> 00:04:07,110
namely a natural number twice
each) and returns a natural number.

00:04:07,110 --> 00:04:08,340
This is set notation: a function.

00:04:08,340 --> 00:04:14,300
A function, given its range of
values and its range of images.

00:04:14,300 --> 00:04:19,070
The Komedia students should know this

00:04:19,070 --> 00:04:22,970
as notation from the second
semester math lecture.

00:04:22,970 --> 00:04:24,530
The computer science students
and the ISE students from

00:04:24,530 --> 00:04:28,010
their respective courses
where set theory is taught.

00:04:28,010 --> 00:04:30,290
Probably, for example, Discrete
Mathematics for the Applied Computer

00:04:30,290 --> 00:04:32,060
Science students.

00:04:32,060 --> 00:04:38,090
I assume that's where it comes in as
notation, very early in the semester.

00:04:38,090 --> 00:04:44,210
Otherwise, at this moment, simply an
operation name "plus", two arguments,

00:04:44,210 --> 00:04:45,980
each natural numbers
(N for natural numbers).

00:04:45,980 --> 00:04:47,750
The result is also a natural number.

00:04:47,750 --> 00:04:49,040
And of course:

00:04:49,040 --> 00:04:52,220
If we have several operations (one
wants to have multiplication too,

00:04:52,220 --> 00:04:55,310
for instance), then they have different
names (but here the same type, the

00:04:55,310 --> 00:04:57,290
same information about
input and output values).

00:05:00,020 --> 00:05:04,340
And, let's say, maybe division.

00:05:04,910 --> 00:05:08,978
Subtraction could also be considered, but
already with division the question arises:

00:05:08,978 --> 00:05:14,090
What type should the output
value be here, anyway?

00:05:14,090 --> 00:05:17,150
And we could say:

00:05:17,150 --> 00:05:18,470
Well, we know what division is.

00:05:18,470 --> 00:05:20,510
But strictly speaking, these are
just currently only information

00:05:20,510 --> 00:05:24,470
about the parameters and the results.

00:05:24,470 --> 00:05:27,050
So here also, if
we know "plus" as addition,

00:05:27,050 --> 00:05:29,600
it is not yet recorded what
operations actually do.

00:05:29,600 --> 00:05:35,960
Right now, we're trying to figure out
what their input and output ranges are.

00:05:35,960 --> 00:05:40,670
And probably here, for example,
you would want to prohibit at

00:05:40,670 --> 00:05:44,660
least division by zero, so that it just
can't be called with five and zero.

00:05:44,660 --> 00:05:45,530
Because it says up here:

00:05:45,530 --> 00:05:48,110
Let N be the set of natural
numbers including zero.

00:05:48,110 --> 00:05:54,920
So you could decide here to say, first
(before deciding what the output range

00:05:54,920 --> 00:06:00,230
will be) refine the
second input range a bit.

00:06:00,230 --> 00:06:02,660
Restrict it a bit by saying:

00:06:02,660 --> 00:06:08,630
We take there the set N+ as notation
for only positive natural numbers.

00:06:08,630 --> 00:06:12,830
Then, for example, one would
statically define the operation

00:06:12,830 --> 00:06:15,410
to simply forbid the
second argument to be zero.

00:06:15,410 --> 00:06:20,300
Then you can naturally use this in
fewer situations.

00:06:20,300 --> 00:06:24,200
You can still use this for
natural numbers,

00:06:24,200 --> 00:06:27,740
which are positive, but just not for
zero itself as a second argument anymore.

00:06:27,740 --> 00:06:30,290
In the first position, you would
still be allowed to have zero.

00:06:30,290 --> 00:06:31,940
So zero by five would still go on.

00:06:33,620 --> 00:06:38,060
Then you would have to somehow think
about the output range as well.

00:06:38,060 --> 00:06:38,990
Above all:

00:06:38,990 --> 00:06:39,740
What does one want here?

00:06:39,740 --> 00:06:43,880
So if you have five and three as
arguments (which would each fit,

00:06:43,880 --> 00:06:47,990
because three is a positive natural
number), what should the result be?

00:06:47,990 --> 00:06:52,670
Should it be 1.666, or
maybe just 1 rounded down?

00:06:52,670 --> 00:06:57,380
Does one do integer division, or does
one want to support rational numbers?

00:06:57,380 --> 00:07:00,950
That is exactly the decision one
makes now in designing this operation.

00:07:00,950 --> 00:07:04,160
Where you decide what
range you want here.

00:07:04,160 --> 00:07:06,530
That would be the decision between:

00:07:06,530 --> 00:07:09,200
I only allow natural numbers here.

00:07:09,200 --> 00:07:14,720
Then I also have to allow zero because 0 / 5 =
0, and for five divided by three, I would want to

00:07:14,720 --> 00:07:17,690
return 1 (so divide by an integer
and discard the remainder).

00:07:17,690 --> 00:07:19,760
Or do I want to support rational numbers?

00:07:19,760 --> 00:07:22,400
Then I would already have to provide here in

00:07:22,400 --> 00:07:25,850
the static design of the operation
that rational numbers may be there.

00:07:25,850 --> 00:07:28,010
Which of course contain the

00:07:28,010 --> 00:07:31,970
natural numbers, but also provide
other candidates as outputs.

00:07:31,970 --> 00:07:34,520
And perhaps one would even want both.

00:07:34,520 --> 00:07:36,665
So the mathematicians like
to do that, of course.

00:07:36,665 --> 00:07:40,460
They always use the same symbol,
overloaded in a certain sense,

00:07:40,460 --> 00:07:43,100
so that it can depend, for example, on

00:07:43,100 --> 00:07:47,750
the context, which expression exactly is
wanted (the integer or the non-integer).

00:07:49,940 --> 00:07:51,710
And, of course, there is
no real "right" or "wrong",

00:07:51,710 --> 00:07:52,910
no right or wrong decision.

00:07:52,910 --> 00:07:54,020
It depends on the
purpose of the application.

00:07:54,020 --> 00:07:56,030
So you can't say:

00:07:56,030 --> 00:07:59,120
This is the right choice and
this is the wrong choice.

00:07:59,120 --> 00:08:00,080
That would be nonsense.

00:08:00,080 --> 00:08:04,550
Ultimately, it is precisely a
part of modeling to work out:

00:08:04,550 --> 00:08:08,270
In the current application
context, what actually is

00:08:08,270 --> 00:08:16,610
the desired area that should be here?

00:08:16,610 --> 00:08:20,870
This could go as far as perhaps supporting both
and then providing suitable mechanisms in the

00:08:20,870 --> 00:08:27,575
system so that this can be decided in each
case depending on the current situation.

00:08:27,575 --> 00:08:29,960
Or at least one would have to
record which variants are available.

00:08:32,370 --> 00:08:35,880
Of course, you also have to be careful
that if you take the rational numbers, for

00:08:35,880 --> 00:08:37,980
example, you suddenly bring
a lot more into play.

00:08:37,980 --> 00:08:41,910
Not only the rational numbers, i.e. the
fractional numbers, but also negative numbers.

00:08:41,910 --> 00:08:45,660
Because the natural numbers, whether with or
without zero, were at least not negative.

00:08:45,660 --> 00:08:50,250
If I choose the rational numbers here,
I would also have to deal with the fact

00:08:50,250 --> 00:08:54,900
that I would then have negative numbers
with them (if I don't limit myself here to

00:08:54,900 --> 00:08:57,600
only positive
and non-negative rational numbers).

00:08:57,600 --> 00:09:00,090
So this is the decision
to make at these points.

00:09:02,910 --> 00:09:07,500
And of course, once I've done that,
once I've introduced N+ or Q instead of

00:09:07,500 --> 00:09:10,350
N, there's also the question of
what about the other operations.

00:09:10,350 --> 00:09:14,970
So "plus" and so on, which before was
only in play for the natural numbers.

00:09:14,970 --> 00:09:19,020
As soon as I have now introduced,
for example, this extra set,

00:09:19,020 --> 00:09:23,670
in order to be able to deal with the division
by zero (by forbidding it), one also asks:

00:09:23,670 --> 00:09:28,560
What about the operation
"plus" that existed before?

00:09:28,560 --> 00:09:31,230
Does this perhaps also somehow
behave differently when one of the

00:09:31,230 --> 00:09:34,050
two argument sets is replaced by N+?

00:09:34,050 --> 00:09:36,870
So the next question would be:

00:09:36,870 --> 00:09:44,520
What would happen now that we have
several different set ranges in play?

00:09:44,520 --> 00:09:48,960
What does that mean for the static
information about the other operations?

00:09:48,960 --> 00:09:52,320
Can we perhaps make those more precise as
well, or do we need to make any changes there?

00:09:53,250 --> 00:09:55,470
In fact, in the specific case,
one can make them more precise.

00:09:55,470 --> 00:09:55,890
Because you know:

00:09:55,890 --> 00:10:01,140
If you have an addition and at
least one of the two summands is

00:10:01,140 --> 00:10:02,430
positive, then the
result is also positive.

00:10:02,430 --> 00:10:04,770
Before, it said: N and N goes to N.

00:10:04,770 --> 00:10:07,440
Now we can additionally state:

00:10:07,440 --> 00:10:15,060
If one of the two parameters, for example the
first one, is a positive number with certainty,

00:10:15,060 --> 00:10:17,340
then after the addition, the
result will also be positive.

00:10:17,340 --> 00:10:18,780
That is more information.

00:10:18,780 --> 00:10:23,400
So, statically, we then know more about the
result than before, where there was only N here.

00:10:23,400 --> 00:10:26,040
That would also have allowed
that zero comes out there.

00:10:26,850 --> 00:10:30,540
This will not happen if at least one
of the two arguments secured is not null.

00:10:32,220 --> 00:10:36,360
Of course, this could be done in
the same way to hold the other position.

00:10:36,360 --> 00:10:39,960
And one could also hold,
for multiplication for example,

00:10:39,960 --> 00:10:43,860
that if both arguments are positive,
the result is also positive.

00:10:44,490 --> 00:10:50,760
But of course, not this information,
because it would be wrong.

00:10:50,760 --> 00:10:57,660
It is not true that a positive number multiplied
by a natural number is always a positive number.

00:10:57,660 --> 00:11:01,740
So here there is
really potential for distinction

00:11:01,740 --> 00:11:05,400
between the operations, which can and
should be held on this operation.

00:11:06,390 --> 00:11:09,510
So then we haven't quite defined
exactly what multiplication does.

00:11:09,510 --> 00:11:15,090
But this restriction, that unlike for
addition, not simply the fact that one of the

00:11:15,090 --> 00:11:19,680
arguments is positive is enough for the
result to be positive as well, that

00:11:19,680 --> 00:11:27,540
can already be held here as a
distinction between these two operations.

00:11:27,540 --> 00:11:28,680
Why all this?

00:11:28,680 --> 00:11:31,500
Because on the basis
of this static information,

00:11:31,500 --> 00:11:35,730
i.e., without having an implementation of the
operation (without really calculating anything),

00:11:35,730 --> 00:11:40,860
we can already determine whether
certain expressions, certain terms,

00:11:40,860 --> 00:11:45,330
certain formulas, which can be
written down, are okay or not okay.

00:11:45,330 --> 00:11:49,230
We have two formulas here that simply

00:11:49,230 --> 00:11:53,520
consist of these operations that
have been introduced so far.

00:11:53,520 --> 00:11:55,590
And if you were to
work those out, you would find

00:11:55,590 --> 00:11:57,668
that this gives you
a number that makes sense.

00:11:57,668 --> 00:11:58,380
Here it comes: five plus zero is five, times
four is twenty, and then we can calculate three

00:11:59,040 --> 00:12:02,010
by twenty.

00:12:02,010 --> 00:12:05,910
Whether dividing by an integer or
not, at least a result is returned.

00:12:05,910 --> 00:12:08,940
Whereas with this expression,
if you wanted to work it

00:12:08,940 --> 00:12:11,520
out, you would run into division by zero.

00:12:11,520 --> 00:12:12,630
But the point is:

00:12:12,630 --> 00:12:16,410
With the static information that was
on the slides before, you can tell

00:12:16,410 --> 00:12:19,890
that this expression is not safe
even without calculating it out.

00:12:22,920 --> 00:12:28,440
Because you don't have a value from N+
standing here, you could use the information,

00:12:28,440 --> 00:12:30,030
with this refinement
of multiplication here,

00:12:30,030 --> 00:12:34,110
to determine that it's not
possible to type this expression.

00:12:34,110 --> 00:12:38,820
So, to use the
operation with the information

00:12:38,820 --> 00:12:43,380
that is here about the parameters
and results to type this expression.

00:12:43,380 --> 00:12:47,160
So you could statically prevent this
expression from being written down at all.

00:12:47,160 --> 00:12:51,150
And then you also know that at runtime,
at the time when the system is supposed

00:12:51,150 --> 00:12:56,860
to operate dynamically, there is no
division-by-zero error, for example.

00:13:00,550 --> 00:13:01,870
And the point here is, of course:

00:13:01,870 --> 00:13:03,850
Sure, I could calculate
something for the numbers,

00:13:03,850 --> 00:13:06,190
but in general, I
don't have concrete numbers.

00:13:06,190 --> 00:13:10,270
In general, I might have an expression
that depends on variables in the program.

00:13:10,270 --> 00:13:11,620
Then I couldn't say anymore:

00:13:11,620 --> 00:13:15,400
I'll calculate this for a test to
see if a division by zero comes out.

00:13:17,230 --> 00:13:20,680
If we have static information
about operations and about the

00:13:20,680 --> 00:13:23,350
variables, we can make such a distinction

00:13:23,350 --> 00:13:27,700
even if we have unknowns there and
therefore cannot calculate concretely.

00:13:28,210 --> 00:13:32,230
That is the purpose of this kind of
static information for operations.

00:13:36,880 --> 00:13:40,090
Now it is like this:

00:13:40,090 --> 00:13:44,740
For these arithmetic operations, you
might think, "Yes, what do we gain here?"

00:13:44,740 --> 00:13:45,550
That's just school arithmetic.

00:13:45,550 --> 00:13:51,430
We know what it means to have a
zero in division, for example.

00:13:51,430 --> 00:13:52,240
That this is a problem.

00:13:52,240 --> 00:13:56,290
But the point is, this handling
of such arithmetic expressions,

00:13:56,290 --> 00:13:58,060
or terms as they
are called, is more general.

00:13:58,060 --> 00:14:05,170
While you may know this from school, having also worked
with such terms and transformed them, it is interesting

00:14:05,170 --> 00:14:10,278
from a modeling point of view that such
an algebraic approach (i.e., describing

00:14:10,278 --> 00:14:19,060
the operations through their signatures, input and
output formats and the rules according to which terms

00:14:19,060 --> 00:14:23,860
are set up) is not only possible for
arithmetic operations on numbers.

00:14:23,860 --> 00:14:27,760
But in general, for operations in
practically any other application

00:14:27,760 --> 00:14:33,070
domains, one has to deal with other sets,
other operation names, and new questions

00:14:33,070 --> 00:14:35,410
about which combinations
should be allowed.

00:14:35,410 --> 00:14:40,450
If you model this precisely, then you have
already recorded certain information about the

00:14:40,450 --> 00:14:48,250
respective application domain before
you start to implement something.

00:14:48,250 --> 00:14:56,200
That should be the goal here
when specifying such operations.

00:14:56,200 --> 00:14:59,320
Now I'll provide an example, and a different
example than the arithmetic operations.

00:14:59,320 --> 00:15:06,340
So let's imagine, as another domain,
that we want to do vector graphics.

00:15:06,340 --> 00:15:09,490
So maybe we would like to
develop a graphics program or

00:15:10,390 --> 00:15:16,330
somehow an app that should have
operations to draw and manipulate images.

00:15:16,330 --> 00:15:18,730
And we want to model that program now.

00:15:18,730 --> 00:15:22,450
That means we're still
going to have numbers, but

00:15:22,450 --> 00:15:25,990
we're now not *just* dealing with mathematical
number domains like we just did, but

00:15:25,990 --> 00:15:30,750
we have to work with other
domain-specific types as well.

00:15:30,750 --> 00:15:36,550
So for number domains, we could now take
mathematical notation like we just did.

00:15:42,640 --> 00:15:44,230
Maybe you learn in parallel,
in the GPT lecture

00:15:44,230 --> 00:15:49,750
(depending on your course of studies),
the programming language Python.

00:15:49,750 --> 00:15:55,000
There are also special data
types, for example, the

00:15:55,000 --> 00:16:01,840
number types for integers and for floating
point numbers, i.e., decimal numbers.

00:16:01,840 --> 00:16:06,220
Maybe also strings, because you want
to have the output in text form.

00:16:06,220 --> 00:16:10,630
And now, here we would want to
introduce more domain-specific types

00:16:10,630 --> 00:16:13,090
that are not necessarily in
the programming language,

00:16:13,090 --> 00:16:17,350
but that we need to support
our vector graphics domain.

00:16:17,350 --> 00:16:19,330
So, what do we
need in the graphics domain?

00:16:19,330 --> 00:16:24,190
Perhaps colors, points,
coordinates, or even whole images.

00:16:27,520 --> 00:16:30,040
So, let's think
about an initial operation.

00:16:30,040 --> 00:16:34,000
What might we have as an
operation that creates an image?

00:16:34,000 --> 00:16:38,140
Maybe we would like to be able
to paint a circle as an image.

00:16:38,140 --> 00:16:39,490
And then we need to think about:

00:16:39,490 --> 00:16:41,350
What parameters does that need?

00:16:41,350 --> 00:16:42,370
At least a radius.

00:16:42,370 --> 00:16:44,575
We could also say, maybe a color.

00:16:44,575 --> 00:16:45,310
But we could also say:

00:16:45,310 --> 00:16:49,690
First of all, a circle by itself is simply
specified by the fact that there is a radius.

00:16:49,690 --> 00:16:51,670
And that could also be a decimal number.

00:16:51,670 --> 00:16:55,870
That's why we introduce an operation called
"circle" which takes a number, interprets

00:16:55,870 --> 00:16:59,080
that number as a
radius, and returns an image.

00:17:01,150 --> 00:17:04,930
We could imagine that if we call
"circle" as an operation with the

00:17:04,930 --> 00:17:07,840
argument 3, then this
picture should be created.

00:17:07,840 --> 00:17:11,590
I will now always show such
pictures here on the right,

00:17:11,590 --> 00:17:16,440
as an idea of
what the operations should do.

00:17:16,440 --> 00:17:22,410
But the modeling itself does
not contain this information.

00:17:22,410 --> 00:17:22,830
Here, it is only about this:

00:17:22,830 --> 00:17:26,460
There is this "circle" operation, which
takes a number and delivers an image.

00:17:26,460 --> 00:17:31,380
The fact that it is this image, in this specific
case, would not be part of the static modeling,

00:17:31,380 --> 00:17:33,390
but already part of the dynamic modeling.

00:17:33,390 --> 00:17:35,820
But maybe this helps a little bit to

00:17:35,820 --> 00:17:37,560
understand what I
want with the operation.

00:17:42,540 --> 00:17:47,550
Although I will always show such examples,
the focus is actually on these operations

00:17:47,550 --> 00:17:51,690
names and their signatures
(information about inputs and outputs).

00:17:54,660 --> 00:18:02,430
Here, it should be noted that 3
is, of course, an integer and not a

00:18:02,430 --> 00:18:06,030
comma, but nevertheless may be used here,
too, if comma numbers are allowed here.

00:18:06,030 --> 00:18:11,220
Because in the end, the set of decimal
numbers is a superset of the set of integers.

00:18:11,220 --> 00:18:13,740
So, every integer is, of
course, also a "decimal number".

00:18:13,740 --> 00:18:18,690
So you don't have to write 3.0
here, you can take 3 directly.

00:18:18,690 --> 00:18:22,500
At least that's how I write it
down now in my example domain.

00:18:29,280 --> 00:18:30,240
That would be a first operation.

00:18:30,240 --> 00:18:32,040
This alone would not be super exciting.

00:18:32,040 --> 00:18:35,070
You could exactly paint circles,
or always exactly one circle.

00:18:35,070 --> 00:18:35,640
This then would be a picture.

00:18:35,640 --> 00:18:40,290
Of course, we don't want to leave it
at that, we want to somehow provide for

00:18:40,290 --> 00:18:44,340
a few more operations when we
design our vector graphics app.

00:18:44,340 --> 00:18:48,600
And for example, we could start to
simply allow different geometric shapes.

00:18:48,600 --> 00:18:51,810
For example, you want to be
able to draw a rectangle.

00:18:51,810 --> 00:18:52,770
You'd have to think about:

00:18:52,770 --> 00:18:53,910
What are the parameters for that?

00:18:53,910 --> 00:18:55,470
There would have to be two now.

00:18:55,470 --> 00:18:57,930
There is no radius, but
perhaps a width and a height.

00:18:57,930 --> 00:19:00,360
And the result is again an image.

00:19:00,360 --> 00:19:06,450
The interpretation would be that if I, for
example, call "rectangle" with 7 and 5,

00:19:06,450 --> 00:19:08,130
I get such a rectangle.

00:19:08,130 --> 00:19:14,280
There is already an interpretation in there, namely,
that the first argument should be interpreted

00:19:14,280 --> 00:19:18,090
as the width, and the second
argument as the height.

00:19:18,090 --> 00:19:21,270
That is not in this specification here.

00:19:21,270 --> 00:19:23,580
As static information, it only contains:

00:19:23,580 --> 00:19:26,310
There are two floating-point arguments.

00:19:26,310 --> 00:19:29,820
And not how they exactly contribute
to the picture in the end.

00:19:29,820 --> 00:19:40,320
What one could also ask here, in the sense
of the arithmetic example domain before:

00:19:40,320 --> 00:19:42,630
What happens if one
of the arguments is zero?

00:19:42,630 --> 00:19:44,640
Even with the
circle, one might ask:

00:19:44,640 --> 00:19:51,810
What if the circle is called with the
argument zero or even with negative radii?

00:19:51,810 --> 00:19:57,990
This could have been countered by
deliberately introducing another set with

00:19:57,990 --> 00:20:02,610
only non-negative floating-point numbers.

00:20:03,240 --> 00:20:06,420
Or one could then make decisions
in the implementation on how

00:20:06,420 --> 00:20:08,460
to deal with such edge cases.

00:20:08,460 --> 00:20:09,120
So maybe:

00:20:09,120 --> 00:20:12,240
A "circle" of size zero
would simply be a point.

00:20:12,240 --> 00:20:18,660
A rectangle of height zero would
simply be a horizontal line.

00:20:18,660 --> 00:20:22,290
And for example, for negative
arguments, either always say

00:20:22,290 --> 00:20:24,990
they are not accepted, or
they are treated like zero.

00:20:26,430 --> 00:20:28,230
That is not expressed here.

00:20:28,230 --> 00:20:33,870
Here, we are first concerned with what combinations
are allowed in principle, syntactically so to speak.

00:20:35,730 --> 00:20:36,960
A few more examples.

00:20:36,960 --> 00:20:38,580
What could further operations be?

00:20:38,580 --> 00:20:41,310
One could introduce another square.

00:20:41,310 --> 00:20:44,640
Maybe you don't need it, because you
can represent a square as a rectangle.

00:20:46,020 --> 00:20:49,290
But it might
become other general operations.

00:20:49,290 --> 00:20:54,420
For example, you might want to draw
general paths, that is, any sequences

00:20:54,420 --> 00:20:59,040
of strokes that don't exactly
make a box like this rectangle.

00:20:59,040 --> 00:21:01,650
What do you need as arguments?

00:21:01,650 --> 00:21:03,930
Some kind of coordinates, i.e., points.

00:21:03,930 --> 00:21:08,130
A point as a combination
of x and y values.

00:21:08,130 --> 00:21:10,200
And for a path, you need several points.

00:21:10,200 --> 00:21:14,400
So maybe a list like that, a listing of
several pairs of coordinates like that.

00:21:14,400 --> 00:21:16,470
You could say:

00:21:19,440 --> 00:21:21,270
A path has a list as an argument.

00:21:21,270 --> 00:21:25,230
This is now to be indicated
here by these square brackets.

00:21:25,230 --> 00:21:28,770
And in this list, coordinate
pairs can be present.

00:21:28,770 --> 00:21:35,350
So (-1,0) would be the first point here, x-axis
-1, y-axis 0, and the next point would be here.

00:21:35,350 --> 00:21:36,940
So behind the dot, dot, dot,

00:21:36,940 --> 00:21:41,140
there would be other such
pairs, for example (1,2).

00:21:42,160 --> 00:21:46,060
Here seems to be (3,0) and then here (6,4).

00:21:46,060 --> 00:21:51,880
So I call the path operation with a
such list of coordinate pairs,

00:21:51,880 --> 00:21:53,290
and then an image comes out.

00:21:53,290 --> 00:21:55,480
In that case, just this zigzag curve.

00:21:58,720 --> 00:22:01,240
And maybe also as another operation:

00:22:01,240 --> 00:22:05,560
Suppose we also want to allow labels
in our images, somehow with text.

00:22:05,560 --> 00:22:08,860
Then we have to have an operation
that converts text into an image.

00:22:08,860 --> 00:22:11,470
And that could be,
for example, simply like this:

00:22:11,470 --> 00:22:13,540
The name "print" might be quite obvious.

00:22:13,540 --> 00:22:17,020
And the argument for this
operation would be a string, a text.

00:22:17,020 --> 00:22:21,160
And the result would be an image,
that represents this text.

00:22:21,160 --> 00:22:23,530
So, for example, print("ABC").

00:22:25,090 --> 00:22:28,930
You probably know these quotation marks
as well, as delimiters for strings

00:22:28,930 --> 00:22:33,550
in many programming languages (or in
the programming language you first learn).

00:22:33,550 --> 00:22:38,530
And then the result here will be a picture
that contains exactly the text ABC.

00:22:41,800 --> 00:22:44,110
So, we could do a
few things with that now.

00:22:44,110 --> 00:22:48,940
Strictly speaking, we could either
draw a circle or draw a rectangle,

00:22:48,940 --> 00:22:55,930
or draw any sequence of strokes
like that, or output a string.

00:22:57,100 --> 00:23:00,010
Now we would like
to have more flexibility.

00:23:00,010 --> 00:23:02,800
For example, this string
here is very small now.

00:23:02,800 --> 00:23:06,010
Maybe you'd rather
have it displayed larger.

00:23:06,010 --> 00:23:13,300
We have designed the print operation in such a way
that it does not specify (as an argument, for example)

00:23:13,300 --> 00:23:17,860
what font size you
want to print this with.

00:23:17,860 --> 00:23:20,710
We could revise that and say:

00:23:20,710 --> 00:23:22,270
Let's introduce an argument here.

00:23:22,270 --> 00:23:23,710
Then we still wouldn't have the

00:23:23,710 --> 00:23:27,430
ability to resize other
graphical objects, for example.

00:23:27,430 --> 00:23:29,590
So, more general, perhaps,
would be to say:

00:23:30,730 --> 00:23:36,130
Outputting a string is always
done in some fixed font size.

00:23:36,670 --> 00:23:40,060
But if we want a string to be displayed

00:23:40,060 --> 00:23:42,970
larger, there is another operation for
that, which can enlarge any image.

00:23:42,970 --> 00:23:46,030
Also including images created using "print".

00:23:46,030 --> 00:23:52,480
If we decide this way, it would
mean that we would introduce an

00:23:52,480 --> 00:23:56,140
operation (and even several operations)
to manipulate existing figures.

00:23:56,140 --> 00:24:01,990
In the operations we have seen so far,
Picture only ever appeared as a result.

00:24:01,990 --> 00:24:04,210
We put a number in, get a picture. We
plug in two numbers, get a picture.

00:24:06,850 --> 00:24:10,120
We plug in a list
of points, we get a picture.

00:24:10,120 --> 00:24:13,750
We put in a string, we get a picture.

00:24:13,750 --> 00:24:15,220
If we want to go beyond

00:24:15,220 --> 00:24:18,580
that, we could provide operations
that have images as inputs as well.

00:24:18,580 --> 00:24:23,410
And for example, for this scaling,
for resizing, we could say:

00:24:23,410 --> 00:24:27,670
We'd like to have
an operation called scale.

00:24:27,670 --> 00:24:35,440
It gets an image, gets two numbers
to be interpreted as scale.

00:24:35,440 --> 00:24:38,522
Enlargement or reduction, depending on
whether it is greater than 1 or less than 1.

00:24:38,522 --> 00:24:42,370
So there should be one factor
each, in x- and y-direction.

00:24:42,370 --> 00:24:42,790
Then we could say:

00:24:42,790 --> 00:24:46,870
Well, if we take the picture, which results
from print("ABC") (that would be this

00:24:46,870 --> 00:24:52,600
small picture here), and we scale that by
the factor 3 in both x and y direction, then

00:24:52,600 --> 00:24:56,710
we get exactly this larger ABC typeface.

00:25:00,010 --> 00:25:02,800
That would be one way of
manipulating existing figures.

00:25:02,800 --> 00:25:03,811
We can think of others.

00:25:03,811 --> 00:25:07,090
For example, if we want
to color the text as

00:25:07,090 --> 00:25:12,160
well, or color other figures, maybe
a "color" operation would be good.

00:25:12,160 --> 00:25:17,260
It has to get an image again, and
it has to get a color passed to it.

00:25:17,260 --> 00:25:20,770
So there has to be
a supply of colors somehow.

00:25:20,770 --> 00:25:23,530
That's just a new set that
would be defined somewhere.

00:25:23,530 --> 00:25:26,380
And the result would be a picture again.

00:25:26,380 --> 00:25:28,240
And then we could say, for example:

00:25:28,240 --> 00:25:31,750
Take the image from just now
(even before scaling, that

00:25:31,750 --> 00:25:34,690
is, the little string
"ABC"), and color it red.

00:25:34,690 --> 00:25:36,880
Then you get this result.

00:25:36,880 --> 00:25:40,000
And wanted would be, of course, if we

00:25:40,000 --> 00:25:44,200
combine this, call both "scale" and
"color" (use nested operations),

00:25:44,200 --> 00:25:47,990
then we should get the big string in red.

00:25:47,990 --> 00:25:50,300
The idea, then, is to
get an image out of here

00:25:50,300 --> 00:25:52,370
that can be used again
as an argument for this.

00:25:53,420 --> 00:25:55,940
We could, of course, combine these
operations, just as in arithmetic we can

00:25:56,690 --> 00:26:00,290
put "plus" and "times" and
"division" etc. into each other.

00:26:00,290 --> 00:26:06,410
And get bigger and bigger expressions, which
are more complicated, but can be evaluated

00:26:06,410 --> 00:26:10,850
with the definitions of the single operations,
by doing several calculation steps.

00:26:13,130 --> 00:26:13,910
What else can we want?

00:26:13,910 --> 00:26:14,750
Scaling, coloring.

00:26:14,750 --> 00:26:16,460
Rotation, for example.

00:26:17,210 --> 00:26:21,710
Our rectangles earlier
were always axis-parallel.

00:26:21,710 --> 00:26:24,170
Maybe we want to
have rectangles that are skewed.

00:26:24,170 --> 00:26:27,770
Then we would need the
ability to rotate an image.

00:26:27,770 --> 00:26:29,330
So we could say:

00:26:29,330 --> 00:26:31,910
Our rectangle from before, that would
be the expression "rectangle(7,5)".

00:26:32,780 --> 00:26:34,580
We'd like to rotate that by an angle.

00:26:34,580 --> 00:26:38,420
Then we would have to somehow
capture, or decide,

00:26:38,420 --> 00:26:40,790
how to interpret that angle.

00:26:40,790 --> 00:26:45,530
Let's assume we measure angles simply
in degrees and not somehow in radians.

00:26:45,530 --> 00:26:52,910
Then 30 just corresponds to a rectangle
tilted about this angle here, with

00:26:52,910 --> 00:26:56,000
the rotation always taking
place about the origin.

00:26:56,000 --> 00:27:04,100
So, what can we do now?

00:27:04,100 --> 00:27:09,140
Now, we have these images that
we can change a little bit.

00:27:09,140 --> 00:27:11,900
But they're always
centered around the origin.

00:27:11,900 --> 00:27:15,440
Which also means, for example, that
rotating a circle makes no sense at all.

00:27:15,440 --> 00:27:21,320
Because the circle was
formed around the origin.

00:27:21,320 --> 00:27:24,650
If we rotate it now, and this
always happens around the origin,

00:27:25,190 --> 00:27:28,940
one can do nothing else with the
circle than paint it and color it.

00:27:31,610 --> 00:27:33,920
You could scale it and
make it an ellipse by

00:27:33,920 --> 00:27:35,630
scaling it differently in
the x- and y-directions.

00:27:35,630 --> 00:27:38,750
But you can't, for example,
draw it in any place other than

00:27:38,750 --> 00:27:41,180
the origin of the coordinate system.

00:27:41,180 --> 00:27:46,070
This is certainly unattractive
for a general graphics app.

00:27:46,070 --> 00:27:50,180
So, we should have at least one
more operation that allows us

00:27:50,180 --> 00:27:55,580
to draw objects at some
place other than the origin.

00:27:55,580 --> 00:28:01,040
And if we would also let all strings
we want to print always overlap at

00:28:01,040 --> 00:28:03,230
the origin, we wouldn't be
able to read anything at all.

00:28:03,230 --> 00:28:05,690
So, what do we need for this?

00:28:05,690 --> 00:28:08,060
Another operation to move an image.

00:28:08,060 --> 00:28:09,890
What does it need as arguments?

00:28:10,850 --> 00:28:14,690
First, the image to be moved, and
then probably two parameters again.

00:28:14,690 --> 00:28:19,040
Like here for the x- and y-directions,
but just not as scaling factors, but

00:28:19,040 --> 00:28:21,410
as displacement values.

00:28:21,410 --> 00:28:26,000
And the result would
be an image, of course.

00:28:26,000 --> 00:28:27,080
So the idea is:

00:28:27,080 --> 00:28:31,850
If we take a circle with a
radius of 3 and shift it in

00:28:31,850 --> 00:28:36,080
the x-direction by 2 and in the
y-direction by 1, we get the same shape,

00:28:36,080 --> 00:28:39,650
the same circle, but it is
now in a different position.

00:28:42,020 --> 00:28:43,400
And the circle
is then completely shifted,

00:28:43,400 --> 00:28:48,410
which is why the centre would now
be at this new position (2,1).

00:28:52,160 --> 00:29:01,720
Then we could draw individual
shapes of our choice, our

00:29:01,720 --> 00:29:06,760
size, our color, our choice of position.

00:29:06,760 --> 00:29:08,770
However, we could not
combine any of these.

00:29:08,770 --> 00:29:13,330
For example, we could not yet draw
an image containing both a circle

00:29:13,330 --> 00:29:15,610
and a rectangle in this way.

00:29:15,610 --> 00:29:19,960
With the operations we have so
far, we would only ever be able to

00:29:19,960 --> 00:29:25,780
paint single geometric shapes
and position them somewhere.

00:29:25,780 --> 00:29:27,580
So, what else would we need?

00:29:27,580 --> 00:29:30,370
What else would be conceivable or
desirable as a meaningful operation?

00:29:30,370 --> 00:29:33,190
Anything that would allow us
to combine multiple images.

00:29:33,190 --> 00:29:37,810
And the easiest choice would
be to introduce a binary

00:29:37,810 --> 00:29:42,040
operation, like the "plus" in numbers ("+"
takes two numbers and returns one number).

00:29:42,040 --> 00:29:43,690
We've only ever had operations until now

00:29:43,690 --> 00:29:46,360
that took at most one image
and returned one image.

00:29:46,360 --> 00:29:49,540
If we want to
combine images, maybe overlap

00:29:49,540 --> 00:29:54,790
them, we need an operation that
composes an image from partial images.

00:29:54,790 --> 00:29:57,400
This could be a binary
operation with two arguments,

00:29:57,400 --> 00:30:00,640
each a Picture, and it
should return a Picture.

00:30:00,640 --> 00:30:06,190
What would be a reasonable use for it?

00:30:06,190 --> 00:30:10,630
For example, we could form
the following expression:

00:30:10,630 --> 00:30:14,320
So somehow a path,
which we have seen before.

00:30:14,320 --> 00:30:16,450
We color it blue.

00:30:16,450 --> 00:30:18,310
Because we may combine the operations.

00:30:18,310 --> 00:30:20,830
That would be a picture expression.

00:30:20,830 --> 00:30:26,290
And we get another image expression by
outputting a piece of text, coloring it, rotating

00:30:26,290 --> 00:30:31,450
it appropriately, and then moving it
from the origin to a different location.

00:30:31,450 --> 00:30:35,290
And then we would have an image that
corresponds to this blue zigzag line, and an

00:30:35,290 --> 00:30:39,520
image that corresponds to
this cleverly positioned text.

00:30:39,520 --> 00:30:44,680
And if we combine that with this new
operation, then we get an image that

00:30:44,680 --> 00:30:45,640
has both in it.

00:30:45,640 --> 00:30:49,870
And now, with these ingredients and the
arbitrary nesting of operations (as we're

00:30:49,870 --> 00:30:56,830
already seeing here), we can already create
quite complex and interesting images.

00:31:00,540 --> 00:31:02,910
One thing to note is that

00:31:02,910 --> 00:31:06,810
this new operation is now
used as an infix operation.

00:31:06,810 --> 00:31:09,390
That is, unlike "move"
and "color" etc., it is

00:31:09,390 --> 00:31:12,000
no longer used with parentheses
around its arguments.

00:31:12,000 --> 00:31:14,430
Instead, you simply write
them between two terms.

00:31:14,430 --> 00:31:16,500
Just as you are
used to in mathematics,

00:31:16,500 --> 00:31:20,209
from arithmetic, that the "plus" is
simply infixed between two numbers.

00:31:20,209 --> 00:31:24,150
So infix in the sense of "between
the operands", between the arguments.

00:31:24,150 --> 00:31:27,990
Instead of as in "move", "rotate", etc.,
that you write the arguments in parentheses.

00:31:27,990 --> 00:31:33,330
This is a common usage, especially
of such symbol operations.

00:31:33,330 --> 00:31:35,580
In doing so, one can also ask oneself:

00:31:35,580 --> 00:31:38,880
For example, can I apply the
operation to three images?

00:31:38,880 --> 00:31:41,940
Probably not directly, because here
it says: there are two images.

00:31:41,940 --> 00:31:45,360
But like I can write down
"plus": 2 + 5 + 4.

00:31:45,360 --> 00:31:49,260
Then I have added three numbers,
although "plus" is a binary operation.

00:31:49,260 --> 00:31:51,720
But again, could I combine more than
two pictures by simply writing: this

00:31:51,720 --> 00:32:01,890
picture, operation symbol, next picture,
operation symbol, next picture again, etc.

00:32:01,890 --> 00:32:05,970
For the Komedia students, for
example, as a reminder of

00:32:05,970 --> 00:32:09,120
the Mathematical Structures
lecture, where we

00:32:09,120 --> 00:32:11,280
considered monoids; that was about
associative operations in algebra.

00:32:11,280 --> 00:32:14,970
Here, you would expect that to
be such an associative operation.

00:32:14,970 --> 00:32:17,910
The other students certainly know

00:32:17,910 --> 00:32:20,640
associativity at least as a
property of "plus" or "times".

00:32:20,640 --> 00:32:25,980
So then, it's okay to use this
operation symbol even if we

00:32:25,980 --> 00:32:29,670
want to combine more than
two images in a row.

00:32:29,670 --> 00:32:40,060
So, now, I just designed some
operations and showed some examples.

00:32:40,060 --> 00:32:45,070
Of course, I won't do an implementation of
them now, that's not what this is about.

00:32:45,070 --> 00:32:50,470
But what is interesting and important
here, and why we introduced this, is that

00:32:50,470 --> 00:32:55,930
we can recognize certain calls/combinations
of operations as useful or

00:32:55,930 --> 00:32:58,060
not useful based
on such static information.

00:32:58,060 --> 00:32:59,830
That's the aspect I mentioned before.

00:32:59,830 --> 00:33:02,350
That such static information can serve to

00:33:02,350 --> 00:33:08,080
exclude certain potential errors,
ultimately, already in the modeling, so

00:33:08,080 --> 00:33:10,240
that they can no longer
occur in the implementation.

00:33:11,170 --> 00:33:14,650
Typical examples would be the following:

00:33:14,650 --> 00:33:17,830
For example, it makes no sense for the

00:33:17,830 --> 00:33:22,900
operation introduced by me to write
something like "circle(circle(3))" here.

00:33:22,900 --> 00:33:25,330
So, "circle(3)" is
a meaningful expression.

00:33:25,330 --> 00:33:30,700
We even saw earlier the picture
that emerges when I interpret that.

00:33:30,700 --> 00:33:35,530
But it doesn't make sense to write
"circle" again because of that.

00:33:36,190 --> 00:33:36,970
Why not?

00:33:36,970 --> 00:33:45,190
Because "circle", according to the signature I had at
the front of the slide, expects a number as an argument.

00:33:45,190 --> 00:33:49,390
Which is true here for this expression.

00:33:49,390 --> 00:33:56,050
But for the outer call, the argument
is not a number, but an image.

00:33:56,050 --> 00:34:00,040
Because 3 is a
number, "circle(3)" is then a

00:34:00,040 --> 00:34:03,550
picture, and I can't put a picture
as an argument into "circle".

00:34:04,420 --> 00:34:07,420
That would be the argument here why
this expression would not be okay.

00:34:07,420 --> 00:34:11,020
Why that's rejected, just based
on the static information.

00:34:11,020 --> 00:34:15,580
In the implementation, if we use a
programming language that takes into

00:34:15,580 --> 00:34:20,440
account such signatures of operations, we would
expect an error message from the compiler.

00:34:20,440 --> 00:34:21,130
That it says:

00:34:21,130 --> 00:34:23,260
This expression makes no
sense, I refuse to

00:34:23,260 --> 00:34:27,520
even create a program for it,
which would then be executable.

00:34:27,520 --> 00:34:37,860
And you can think of various other cases
that are okay and that are not okay.

00:34:37,860 --> 00:34:41,520
On the slide, I've listed a
few cases that are not okay.

00:34:41,520 --> 00:34:46,620
Each with a short intuitive explanation as
to why this expression would not be okay.

00:34:46,620 --> 00:34:48,000
This expression would not be okay

00:34:48,000 --> 00:34:52,710
because "circle(3)" is again an image,
and that itself is not printable text.

00:34:52,710 --> 00:34:55,710
So "print" expects a string,

00:34:55,710 --> 00:34:58,950
a string like text, which is
then converted to an image.

00:34:58,950 --> 00:35:02,010
I can't pass "print" a
already completed image.

00:35:02,010 --> 00:35:03,930
Then "print" would not
know what to print.

00:35:03,930 --> 00:35:07,410
It would not, as the operations are

00:35:07,410 --> 00:35:10,320
interpreted here, print the
text "circle(3)" somehow.

00:35:10,320 --> 00:35:12,540
For that, it would have to be
enclosed in quotation marks.

00:35:12,540 --> 00:35:16,530
Yes, "print" can print any text, but
it would have to be clear somehow,

00:35:16,530 --> 00:35:19,800
by quotation marks, that
you really have a

00:35:19,800 --> 00:35:23,820
string there and not another expression
to be interpreted as an image.

00:35:27,780 --> 00:35:31,530
For the same reasons, something
like "print(3)" would not be okay,

00:35:31,530 --> 00:35:32,880
at least in my interpretation.

00:35:33,480 --> 00:35:38,970
There are programming languages
where, if there is a 3, it would just

00:35:38,970 --> 00:35:42,540
be silently implemented
as the string "3".

00:35:42,540 --> 00:35:45,420
I don't want to allow that here.

00:35:45,420 --> 00:35:51,150
I had imagined strings
and numbers as different

00:35:51,150 --> 00:35:54,750
things, respectively
named them differently.

00:35:55,320 --> 00:36:01,050
That means, "print-from-3" would not be a valid expression
in my example domain here,

00:36:01,050 --> 00:36:05,280
because it is not true that the
3 itself is a string.

00:36:05,280 --> 00:36:08,040
For that, it would have to be enclosed
in quotation marks.

00:36:09,870 --> 00:36:13,560
And for none of these observations
must I somehow run the program

00:36:13,560 --> 00:36:16,230
and paint the things, that is, create images.

00:36:16,230 --> 00:36:19,170
I can already determine all that
from the static information.

00:36:19,170 --> 00:36:22,530
Here's another mistake.

00:36:22,530 --> 00:36:25,800
Here's the error: we applied
"print" to a string, and

00:36:25,800 --> 00:36:28,680
an image comes out; here I'd like
to scale it by a factor of 3.

00:36:28,680 --> 00:36:30,900
Why is this still wrong?

00:36:30,900 --> 00:36:32,760
Because this has the
wrong number of arguments.

00:36:32,760 --> 00:36:33,450
I introduced up front:

00:36:33,450 --> 00:36:36,870
"scale" always takes two arguments in
addition to the image, i.e., two numbers, to

00:36:36,870 --> 00:36:39,240
be able to scale in x and y directions.

00:36:39,240 --> 00:36:40,800
If I forget one of

00:36:40,800 --> 00:36:44,250
them, I would expect that to
be a non-valid expression here.

00:36:44,250 --> 00:36:48,490
So even if you only want one
factor to scale, you have to

00:36:48,490 --> 00:36:52,540
specify it twice to use it
for both x and y directions.

00:36:52,540 --> 00:36:58,900
For coloring, we need an
image and a color to use.

00:36:58,900 --> 00:37:01,411
But it was specified as:

00:37:01,411 --> 00:37:03,490
You specify the image
first and then the color.

00:37:03,490 --> 00:37:07,360
And if I do that the wrong way around, I
would expect that to be rejected here as well.

00:37:14,620 --> 00:37:18,970
Again, more of an error like the one above.

00:37:18,970 --> 00:37:23,740
So "rotate" expects an image and an angle,

00:37:23,740 --> 00:37:27,910
rather than two angles or
anything that is a number.

00:37:27,910 --> 00:37:33,670
Here in front, there should be an image,
and the number 30 itself is not an image.

00:37:33,670 --> 00:37:38,890
You can print 30 with "print("30")", and then
you would have an image that you could rotate.

00:37:38,890 --> 00:37:45,520
But the number 30 itself is not an
image and therefore cannot be rotated.

00:37:45,520 --> 00:37:48,610
Our combination operator was
meant for images.

00:37:48,610 --> 00:37:54,190
So, as was said, the specification was
for a Picture and also a Picture, and

00:37:54,190 --> 00:37:55,660
the result would be a Picture.

00:37:55,660 --> 00:38:00,430
For "ABC" and "DEF", you could imagine that
you want to pack them together somehow.

00:38:00,430 --> 00:38:03,760
Maybe you want to
get the string "ABCDEF".

00:38:03,760 --> 00:38:06,040
For this, one would have to
introduce another operation, however.

00:38:06,040 --> 00:38:12,340
The operation "and" with this symbol was
introduced as an operation between pictures.

00:38:12,340 --> 00:38:17,935
And "ABC" as well as
"DEF" are just not pictures.

00:38:17,935 --> 00:38:19,120
So we have a whole set of errors,

00:38:19,120 --> 00:38:25,660
which one could exclude, simply by
adhering to the operation signatures.

00:38:25,660 --> 00:38:29,770
Conversely, of course, this does not mean that all
programming errors are automatically detectable.

00:38:29,770 --> 00:38:34,480
So, for instance, with the rectangle
operation, the requirement was:

00:38:34,480 --> 00:38:35,680
You have to specify two numbers.

00:38:35,680 --> 00:38:40,570
And I had interpreted the first number
as width and the second as height.

00:38:40,570 --> 00:38:43,270
But of course, this is not in

00:38:43,270 --> 00:38:49,420
the signature, in this specification
on the corresponding slide.

00:38:49,420 --> 00:38:52,090
Here, from this, you can't tell what
the height is and what the width is.

00:38:52,090 --> 00:38:52,510
That is:

00:38:52,510 --> 00:39:00,820
Even if I actually want to draw a
rectangle that is wider than it is high,

00:39:00,820 --> 00:39:05,440
like this, but accidentally write
"rectangle(5,7)" instead of "rectangle(7,5)",

00:39:05,440 --> 00:39:10,930
that would be an error that
cannot be detected statically.

00:39:11,500 --> 00:39:14,050
Because the role of these two

00:39:14,620 --> 00:39:19,570
arguments isn't fixed by the static
information from the previous slides.

00:39:19,570 --> 00:39:20,260
That is:

00:39:20,260 --> 00:39:24,010
An error that I make there is simply an
error that I would notice only dynamically at

00:39:24,010 --> 00:39:27,580
runtime, at execution time
of my app / program.

00:39:27,580 --> 00:39:32,200
But a whole series of possible
errors is already caught statically.

00:39:32,200 --> 00:39:37,840
And, depending on the programming language, more
or less of such errors are acceptable here,

00:39:37,840 --> 00:39:42,160
of course, or are
waved through, so to speak.

00:39:42,160 --> 00:39:44,470
So in Python,
"print(3)" would probably work.

00:39:44,470 --> 00:39:45,520
That would simply be interpreted.

00:39:45,520 --> 00:39:49,270
In my domain here, I had
specified that I don't want that.

00:39:49,270 --> 00:39:52,840
So, there has
to be a string explicitly.

00:39:56,920 --> 00:40:01,870
That's practically the end of this part.

00:40:01,870 --> 00:40:05,200
One little comment, one little
note, I would like to make.

00:40:05,200 --> 00:40:11,770
And that is for those of you who know
programming languages like C or Java.

00:40:11,770 --> 00:40:16,240
That's not necessarily the case for all of you, because,
for example, the programming introduction at our

00:40:16,240 --> 00:40:20,650
school is now with Python, for
Komedia and Applied Computer Science.

00:40:20,650 --> 00:40:24,340
But if you know C or Java from
school, for example, then on

00:40:24,340 --> 00:40:30,190
the one hand, you understand the concept of such
operations, such specifications of signatures.

00:40:30,190 --> 00:40:32,380
On the other hand, you know
a different syntax for it.

00:40:32,380 --> 00:40:35,020
So there it is
not specified so mathematically.

00:40:35,020 --> 00:40:39,400
Therefore, a small slide, where
simply this connection is made, how

00:40:39,400 --> 00:40:42,340
these correspond to each other.

00:40:42,340 --> 00:40:46,420
So this "rectangle" operation,
for example, which I

00:40:46,420 --> 00:40:54,760
have defined or declared, is passed
two numbers and returns an image.

00:40:54,760 --> 00:40:59,920
In C or Java, and many other mostly
object-oriented or simply imperative programming

00:40:59,920 --> 00:41:01,900
languages, it would correspond to

00:41:02,480 --> 00:41:06,260
a declaration of the following kind (if
they are typed programming languages):

00:41:06,800 --> 00:41:11,630
The name "rectangle" would be used
here as the name of a function.

00:41:14,780 --> 00:41:18,860
The result type, i.e., what output
comes out (which is the last quantity

00:41:18,860 --> 00:41:24,980
here in mathematical notation),
is then often specified first.

00:41:24,980 --> 00:41:29,600
So, "rectangle" returns an image and
gets the arguments passed to it,

00:41:29,600 --> 00:41:32,570
which are here to the left of the arrow.

00:41:32,570 --> 00:41:38,600
So, here we see that two floating
point numbers are passed.

00:41:38,600 --> 00:41:40,490
And often a name for the

00:41:40,490 --> 00:41:43,490
parameters is given directly
in the programming language.

00:41:43,490 --> 00:41:47,780
This provides a little bit
more information, if x and

00:41:47,780 --> 00:41:51,290
y are interpreted geometrically
as the x and y coordinates.

00:41:51,290 --> 00:41:53,090
There could be arbitrary names for

00:41:53,090 --> 00:41:56,750
it, but of course, names are gladly
assigned which already say something

00:41:56,750 --> 00:42:01,640
about the intention of the operation
and the use of the arguments.

00:42:03,710 --> 00:42:06,860
So, this is noted here simply because

00:42:06,860 --> 00:42:11,570
many of you may
know this kind of notation.

00:42:11,570 --> 00:42:16,700
And then, you should just be able to match it very
directly to how I just declared the operations here

00:42:16,700 --> 00:42:23,465
now in the slides, and how it's going to
happen in the corresponding exercise as well.

00:42:23,465 --> 00:42:26,840
So, that's almost the same information,
just written down differently.
